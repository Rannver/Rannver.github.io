{"meta":{"title":"Rannver's Blog","subtitle":null,"description":null,"author":"Rannver","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-09-14T11:47:05.447Z","updated":"2017-09-14T11:47:05.447Z","comments":true,"path":"index/index.html","permalink":"http://yoursite.com/index/index.html","excerpt":"","text":"你好，这里是一枚小白程序员的小博客w谢谢你花费宝贵的时间浏览我的博客，希望能够对你有所帮助。 如果有宝贵的建议或意见，请联系我： rannverqy@gmail.com"},{"title":"","date":"2017-09-14T11:48:47.525Z","updated":"2017-09-14T11:48:47.525Z","comments":true,"path":"history/index.html","permalink":"http://yoursite.com/history/index.html","excerpt":"","text":""}],"posts":[{"title":"用一个简单的demo了解观察者模式","slug":"用一个简单的demo了解观察者模式","date":"2017-10-19T13:04:30.959Z","updated":"2017-10-19T13:04:34.104Z","comments":true,"path":"2017/10/19/用一个简单的demo了解观察者模式/","link":"","permalink":"http://yoursite.com/2017/10/19/用一个简单的demo了解观察者模式/","excerpt":"","text":"一、什么是观察者模式定义对象间的一种一对多的依赖关系，当一个对象（被观察者Observable）的状态发生改变时，依赖于它的对象（Observer）都得到通知并且被自动更新。 被观察者（Observable）的核心方法： setChange();//告知数据改变 notifyObservers();//给观察者发送信号 观察者（Observer）的核心方法： update(Observable observable, Object o);//观察者接到信号后更新 二、为什么要使用观察者模式优点：1、关联行为，并且行为可拆分，而不是组合关系2、解除耦合，使得各自的变换都不会影响另一边的变换 缺点：需要考虑开发效率和运行效率的问题，java中的消息通知一般是顺序执行，如果一个观察者卡顿（比如陷入死循环），会产生如下效果： while(1){ // 死循环懵逼.jpg } 这时候需要注意判断需求是否需要异步实现。 三、以天气-气象站为例的简单观察者模式（使用Observable和Observer）作为被观察者的天气：public class Weather extends Observable { private String description; public Weather(String des){ this.description = des; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; setChanged(); notifyObservers(); } @Override protected synchronized void setChanged() { super.setChanged(); Log.d(\"Observable\",\"Weather发生了改变：\"+description); } @Override public void notifyObservers() { super.notifyObservers(); Log.d(\"Observable\", \"notifyObservers: \"+\"已经通知了气象站\"); } } 作为观察者的气象站：public class Station implements Observer { private static String TAG = \"Observer\"; private MainActivity activity; public Station(MainActivity activity,Weather weather){ this.activity = activity; } @Override public void update(Observable observable, Object o) { Log.d(TAG, \"update\"); if (observable instanceof Weather){ Weather weather2 = (Weather) observable; activity.Change(weather2.getDescription()); } } } 使用：private Weather weather = new Weather(\"\"); //被观察者 private Station station = new Station(MainActivity.this);//观察者 weather.addObserver(station);//划重点!! 然后就可以愉快的使用观察者模式了，当然，这只是最最最最简单的观察者模式，在实际情况中，我们会用到更复杂的写法。","categories":[],"tags":[{"name":"Android 设计模式 观察者模式","slug":"Android-设计模式-观察者模式","permalink":"http://yoursite.com/tags/Android-设计模式-观察者模式/"}]},{"title":"与MPAndroidChart的初步接触","slug":"与MPAndroidChart的初步接触","date":"2017-09-15T12:51:33.226Z","updated":"2017-09-15T12:51:42.299Z","comments":true,"path":"2017/09/15/与MPAndroidChart的初步接触/","link":"","permalink":"http://yoursite.com/2017/09/15/与MPAndroidChart的初步接触/","excerpt":"","text":"一、使用方法 在 build.gradle 添加下面的代码： 1234567repositories &#123; maven &#123; url \"https://jitpack.io\" &#125;&#125;dependencies &#123; compile 'com.github.PhilJay:MPAndroidChart:v2.1.6'&#125; 下载jar文件https://github.com/PhilJay/MPAndroidChart/releases 二、数据设置（此处以Barchart为例） 1. 设置X轴由于X轴需要显示的坐标可以是多种多样的（数值、日期、分类等等），所以需要一个ArrayList的String用来描述X轴的标签。1234ArrayList&lt;String&gt; xValues = new ArrayList&lt;&gt;();for (int i = 0;i&lt;10;i++)&#123; xValues.add(String.valueOf(i));&#125; 2. 设置y轴y轴的设置需要一个Entry类型的ArrayList封装图表的所有值。 设置y轴数据：（示例中使用的是MPAndroidChart中写好的Barchart的BarEntry）1234ArrayList&lt;BarEntry&gt; yValues = new ArrayList&lt;&gt;();for (int i = 0;i&lt;10;i++)&#123; yValues.add(new BarEntry(i,i));&#125; 设置y轴数据的集合：123BarDataSet barDataSet = new BarDataSet(yValues,\"index\");ArrayList&lt;IBarDataSet&gt; barDataSets = new ArrayList&lt;&gt;();barDataSets.add(barDataSet); 3. 设置数据用setData()设置图表，BarData提供一个图表所需的所有的数据。12BarData barData = new BarData(xValues, barDataSets);barchart.setData(barData); 三、图表属性1. 常用的几个属性:setTouchEnabled(boolean enabled) : 启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled) : 启用/禁用拖动（平移）图表。 setScaleXEnabled(boolean enabled) : 启用/禁用缩放在x轴上。 setScaleYEnabled(boolean enabled) : 启用/禁用缩放在y轴。 2. X、Y轴的设置（XAxis、YAxis）XAxis和YAxis都是AxisBase的一个子类，是所有与X、Y轴相关的“数据和信息的容器”。 常用的几个属性： X、Y轴通用： setTextColor(int color) : 设置轴标签的颜色。 setTextSize(float size) : 设置轴标签的文字大小。 setGridColor(int color) : 设置该轴的网格线颜色。 setGridLineWidth(float width) : 设置该轴网格线的宽度。 setAxisLineColor(int color) : 设置轴线的轴的颜色。 setAxisLineWidth(float width) : 设置该轴轴行的宽度。 X轴： setSpaceBetweenLabels(int characters) : 设置标签字符间的空隙，默认characters间隔是4 。 setLabelsToSkip(int count) : 设置在”绘制下一个标签”时，要忽略的标签数。 setPosition(XAxisPosition pos) : 设置XAxis出现的位置。（TOP，BOTTOM等） Y轴： setStartAtZero(boolean enabled) : 设置为 true，则无论图表显示的是哪种类型的数据，该轴最小值总是0 。 setLabelCount(int count, boolean force) : 设置y轴的标签数量。确切绘制指定数量的标签，但这样可能导致轴线分布不均匀。 setShowOnlyMinMax(boolean enabled) : 如果启用，该轴将只显示它的最小值和最大值。 setPosition(YAxisLabelPosition pos) : 设置，其中轴标签绘制的位置。（OUTSIDE_CHART 或 INSIDE_CHART）。 四、关于MPAndroidChart的更多请访问 官方 或 MPAndroidChart教程：概述 -庄宏基","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]}