{"meta":{"title":"Rannver's Blog","subtitle":null,"description":null,"author":"Rannver","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-09-14T11:48:47.525Z","updated":"2017-09-14T11:48:47.525Z","comments":true,"path":"history/index.html","permalink":"http://yoursite.com/history/index.html","excerpt":"","text":""},{"title":"","date":"2017-09-14T11:47:05.447Z","updated":"2017-09-14T11:47:05.447Z","comments":true,"path":"index/index.html","permalink":"http://yoursite.com/index/index.html","excerpt":"","text":"你好，这里是一枚小白程序员的小博客w谢谢你花费宝贵的时间浏览我的博客，希望能够对你有所帮助。 如果有宝贵的建议或意见，请联系我： rannverqy@gmail.com"}],"posts":[{"title":"总结一下几种目前接触到的Retrofit使用方法","slug":"总结一下几种目前接触到的Retrofit使用方法","date":"2017-10-19T13:32:02.176Z","updated":"2017-10-19T13:49:58.162Z","comments":true,"path":"2017/10/19/总结一下几种目前接触到的Retrofit使用方法/","link":"","permalink":"http://yoursite.com/2017/10/19/总结一下几种目前接触到的Retrofit使用方法/","excerpt":"","text":"一、最最最最最最基本的用法一股脑的写法，缺点很明显，会造成代码很长而且不够简洁，不方便后来的阅读和维护。 Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"(这里填写的是url)\") .addConverterFactory(GsonConverterFactory.create()) //这里是为了直接用Gson解析数据，也可以不写，之后用ResponseBody .build; HotService service = retrofit.create(HotWebServce.class); call call = getMovieService.getHotList(\"武汉\");//传入请求参数 call.enqueue(new MoiveCallback() { @Override public void onResponse(Call call, Response response) { super.onResponse(call, response); //这里做请求成功的逻辑 } @Override public void onFailure(Call call, Throwable t) { super.onFailure(call, t); //这里做请求失败的逻辑 } }); 二、之前一直在用的方法将前半部分封装起来，直接调用，比第一种方法稍微简洁一些。缺点：会产生很多的文件，对于少量数据接口请求可以使用。 #####1、创建BaseWebApi： public abstract class BaseWebApi { public String baseUrl = \"http://api.douban.com/v2/movie/\"; Retrofit getApi(String url){ return new Retrofit.Builder() .baseUrl(url) .addConverterFactory(GsonConverterFactory.create()) .build(); } public abstract T getServce(); } #####2、每一个WebApi都继承自BaseWebApi： public class HotWebApi extends BaseWebApi { Retrofit retrofit = getApi(baseUrl); @Override public T getServce() { return (T) retrofit.create(HotWebServce.class); } } #####3、使用： HotWebApi hotWebApi = new HotWebApi(); HotWebServce webServce = hotWebApi.getServce(); Call call = webServce.getState(\"武汉\"); call.enqueue(new Callback() { @Override public void onResponse(Call call, final Response response) { …… } @Override public void onFailure(Call call, Throwable t) { …… } }); 注：若需要打印url可使用：call.request().url().toString() 三、基于第二种方法并且减少创建的操作封装Retrofit、CallBack 使用： GetMovieService getMovieService = RetrofitUtil.retrofit(MovieApi.MOIVE_API) .create(GetMovieService.class); Call call = getMovieService.getHotList(\"武汉\"); call.enqueue(new MoiveCallback() { @Override public void onResponse(Call call, Response response) { super.onResponse(call, response); …… } @Override public void onFailure(Call call, Throwable t) { super.onFailure(call, t); } }); 四、Rxjava+Retrofit进行网络请求1、什么是rxjavaRxJava 类似 观察者模式。有一个Observable(被观察者，事件的发起者)和一个观察者(Subscriber，事件的接收者)。Observable发出一系列的事件，然后Subscriber处理这些事件。Observable 可以发送零到多个事件。Subscriber会接收它发的每一个事件。如果Observable没有对应的Subscriber,不会发送任何事件。 本质上说：一个实现异步操作的库，并且随着程序逻辑越来越复杂，rxjava依旧能够保持简洁 简单的了解什么是观察者模式 2、为什么要用rxjava3、使用Service： @GET(\"in_theaters\") Observable getHotList(@Query(\"city\") String city); retrofit部分： //retrofit部分 public T create(Class service,String baseUrl){ return new Retrofit.Builder() .baseUrl(baseUrl) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) //加这一句（很关键 .build() .create(service); } 使用方法一： RxMoiveService rxMoiveService = MoiveClient.getInstance().create(RxMoiveService.class,MovieApi.MOIVE_API); rxMoiveService.getHotList(\"武汉\") .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer() { @Override public void accept(MoiveListGsonBean moiveListGsonBean) throws Exception { …… } }, new Consumer() { @Override public void accept(Throwable throwable) throws Exception { …… } }); 使用方法二： RxMoiveService rxMoiveService = MoiveClient.getInstance().create(RxMoiveService.class,MovieApi.MOIVE_API); rxMoiveService.getFutureList() .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, \"onSubscribe\"); } @Override public void onNext(MoiveListGsonBean value) { Log.d(TAG, \"onNext\"); …… } @Override public void onError(Throwable e) { Log.d(TAG, \"onError\"); } @Override public void onComplete() { Log.d(TAG, \"onComplete\"); } }); 注：Consumer类：简易版本的Observer，可以自定义需要处理的信息 关于Rxjava的深入学习：给 Android 开发者的 RxJava 详解Rxjava的github：ReactiveX/RxJavaRxAndroid的github：ReactiveX/RxAndroid","categories":[],"tags":[{"name":"Android  retrofit rxjava","slug":"Android-retrofit-rxjava","permalink":"http://yoursite.com/tags/Android-retrofit-rxjava/"}]},{"title":"用一个简单的demo了解观察者模式","slug":"用一个简单的demo了解观察者模式","date":"2017-10-19T13:04:30.959Z","updated":"2017-10-19T13:04:34.104Z","comments":true,"path":"2017/10/19/用一个简单的demo了解观察者模式/","link":"","permalink":"http://yoursite.com/2017/10/19/用一个简单的demo了解观察者模式/","excerpt":"","text":"一、什么是观察者模式定义对象间的一种一对多的依赖关系，当一个对象（被观察者Observable）的状态发生改变时，依赖于它的对象（Observer）都得到通知并且被自动更新。 被观察者（Observable）的核心方法： setChange();//告知数据改变 notifyObservers();//给观察者发送信号 观察者（Observer）的核心方法： update(Observable observable, Object o);//观察者接到信号后更新 二、为什么要使用观察者模式优点：1、关联行为，并且行为可拆分，而不是组合关系2、解除耦合，使得各自的变换都不会影响另一边的变换 缺点：需要考虑开发效率和运行效率的问题，java中的消息通知一般是顺序执行，如果一个观察者卡顿（比如陷入死循环），会产生如下效果： while(1){ // 死循环懵逼.jpg } 这时候需要注意判断需求是否需要异步实现。 三、以天气-气象站为例的简单观察者模式（使用Observable和Observer）作为被观察者的天气：public class Weather extends Observable { private String description; public Weather(String des){ this.description = des; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; setChanged(); notifyObservers(); } @Override protected synchronized void setChanged() { super.setChanged(); Log.d(\"Observable\",\"Weather发生了改变：\"+description); } @Override public void notifyObservers() { super.notifyObservers(); Log.d(\"Observable\", \"notifyObservers: \"+\"已经通知了气象站\"); } } 作为观察者的气象站：public class Station implements Observer { private static String TAG = \"Observer\"; private MainActivity activity; public Station(MainActivity activity,Weather weather){ this.activity = activity; } @Override public void update(Observable observable, Object o) { Log.d(TAG, \"update\"); if (observable instanceof Weather){ Weather weather2 = (Weather) observable; activity.Change(weather2.getDescription()); } } } 使用：private Weather weather = new Weather(\"\"); //被观察者 private Station station = new Station(MainActivity.this);//观察者 weather.addObserver(station);//划重点!! 然后就可以愉快的使用观察者模式了，当然，这只是最最最最简单的观察者模式，在实际情况中，我们会用到更复杂的写法。","categories":[],"tags":[{"name":"Android 设计模式 观察者模式","slug":"Android-设计模式-观察者模式","permalink":"http://yoursite.com/tags/Android-设计模式-观察者模式/"}]},{"title":"与MPAndroidChart的初步接触","slug":"与MPAndroidChart的初步接触","date":"2017-09-15T12:51:33.226Z","updated":"2017-09-15T12:51:42.299Z","comments":true,"path":"2017/09/15/与MPAndroidChart的初步接触/","link":"","permalink":"http://yoursite.com/2017/09/15/与MPAndroidChart的初步接触/","excerpt":"","text":"一、使用方法 在 build.gradle 添加下面的代码： 1234567repositories &#123; maven &#123; url \"https://jitpack.io\" &#125;&#125;dependencies &#123; compile 'com.github.PhilJay:MPAndroidChart:v2.1.6'&#125; 下载jar文件https://github.com/PhilJay/MPAndroidChart/releases 二、数据设置（此处以Barchart为例） 1. 设置X轴由于X轴需要显示的坐标可以是多种多样的（数值、日期、分类等等），所以需要一个ArrayList的String用来描述X轴的标签。1234ArrayList&lt;String&gt; xValues = new ArrayList&lt;&gt;();for (int i = 0;i&lt;10;i++)&#123; xValues.add(String.valueOf(i));&#125; 2. 设置y轴y轴的设置需要一个Entry类型的ArrayList封装图表的所有值。 设置y轴数据：（示例中使用的是MPAndroidChart中写好的Barchart的BarEntry）1234ArrayList&lt;BarEntry&gt; yValues = new ArrayList&lt;&gt;();for (int i = 0;i&lt;10;i++)&#123; yValues.add(new BarEntry(i,i));&#125; 设置y轴数据的集合：123BarDataSet barDataSet = new BarDataSet(yValues,\"index\");ArrayList&lt;IBarDataSet&gt; barDataSets = new ArrayList&lt;&gt;();barDataSets.add(barDataSet); 3. 设置数据用setData()设置图表，BarData提供一个图表所需的所有的数据。12BarData barData = new BarData(xValues, barDataSets);barchart.setData(barData); 三、图表属性1. 常用的几个属性:setTouchEnabled(boolean enabled) : 启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled) : 启用/禁用拖动（平移）图表。 setScaleXEnabled(boolean enabled) : 启用/禁用缩放在x轴上。 setScaleYEnabled(boolean enabled) : 启用/禁用缩放在y轴。 2. X、Y轴的设置（XAxis、YAxis）XAxis和YAxis都是AxisBase的一个子类，是所有与X、Y轴相关的“数据和信息的容器”。 常用的几个属性： X、Y轴通用： setTextColor(int color) : 设置轴标签的颜色。 setTextSize(float size) : 设置轴标签的文字大小。 setGridColor(int color) : 设置该轴的网格线颜色。 setGridLineWidth(float width) : 设置该轴网格线的宽度。 setAxisLineColor(int color) : 设置轴线的轴的颜色。 setAxisLineWidth(float width) : 设置该轴轴行的宽度。 X轴： setSpaceBetweenLabels(int characters) : 设置标签字符间的空隙，默认characters间隔是4 。 setLabelsToSkip(int count) : 设置在”绘制下一个标签”时，要忽略的标签数。 setPosition(XAxisPosition pos) : 设置XAxis出现的位置。（TOP，BOTTOM等） Y轴： setStartAtZero(boolean enabled) : 设置为 true，则无论图表显示的是哪种类型的数据，该轴最小值总是0 。 setLabelCount(int count, boolean force) : 设置y轴的标签数量。确切绘制指定数量的标签，但这样可能导致轴线分布不均匀。 setShowOnlyMinMax(boolean enabled) : 如果启用，该轴将只显示它的最小值和最大值。 setPosition(YAxisLabelPosition pos) : 设置，其中轴标签绘制的位置。（OUTSIDE_CHART 或 INSIDE_CHART）。 四、关于MPAndroidChart的更多请访问 官方 或 MPAndroidChart教程：概述 -庄宏基","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]}